1926 해설

우선 main을 보자. 처음에 n(행), m(열)을 받고, 그림 데이터를 저장할 map 2차 행렬 인스턴스를 생성해. 또한 chk boolean 이차행렬로 방문했는지 여부를 확인할 수있는 인스턴스를 생성해.

for문으로 입력 받은 걸 전부 저장한 다음,
for문으로 하나씩 1이면서 방문한 곳이 아닌지를 체크해. 그게 그림의 시작이 되는 거지. 그리고 bfs로 이 그림이 얼마 크기인지를 받아. 그 다음 maxArea랑 비교해서 최신화해.

전역변수를 보면, int n,m(2차원 행렬 크기)
int[][] map (2차원 행렬)
int [] dy = {0,1,0,-1}
int [] dx = {1,0,-1,0}
이건 좌우상하 데이터값을 확인해보는 거. 

bfs 함수 안에서는 y,x를 받으면, 그 배열을 Queue에 넣고, 너비를 1로. 
while 해서 큐가 비워질 때까지 첫번째 값을 cur 배열에 poll 하고, 
현재 위치인 ey, ex에서 상하좌우의 ny,nx가 만약 배열 내부 안에 있으면서 1이면서 방문을 안했다면, 방문하면서 area를 2로 늘리면서 그 좌표를 q에 넣는다. 그럼 안비었으니깐 while문은 실행된다.
만약 비어있다면 while문은 종료됨.
